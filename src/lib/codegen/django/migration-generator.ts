import type { Diagram, AppNode, AppEdge, Column } from "../../types";
import {
  toDjangoTableName,
  toDjangoModelName,
  generateTimestamp,
  getDjangoFieldType,
  extractFieldOptions,
  getDjangoOnDeleteAction,
  escapeString,
} from "./django-helpers";
import { exportToSql } from "@/lib/dbml";

export interface DjangoMigrationOptions {
  timestamp?: string;
}

export interface DjangoMigrationFile {
  filename: string;
  content: string;
}

function generateDjangoMigration(
  diagram: Diagram,
  options: DjangoMigrationOptions = {}
): DjangoMigrationFile[] {
  const { nodes, edges } = diagram.data;
  const timestamp = options.timestamp || generateTimestamp();

  // Generate single migration file with all tables
  const filename = `0001_initial.py`;
  const content = generateInitialMigration(diagram, timestamp);

  return [{ filename, content }];
}

function generateDjangoMigrationString(
  diagram: Diagram,
  options: DjangoMigrationOptions = {}
): string {
  const files = generateDjangoMigration(diagram, options);

  if (files.length === 0) {
    return "# No tables found to generate migrations";
  }

  const output = `"""
Django Migration Files Generated from Database Diagram
Generated on: ${new Date().toLocaleString()}
Database Type: ${diagram.dbType === 'postgres' ? 'PostgreSQL' : 'MySQL'}

Instructions:
1. Copy each migration block below into separate files in your Django app
2. Place them in the migrations/ directory of your Django app
3. Run 'python manage.py migrate' to execute the migrations

Note: Each migration file is independent and includes all table structure
"""

`;

  return (
    output +
    files
      .map((f) => `# File: ${f.filename}\n${f.content}`)
      .join("\n\n" + "=".repeat(80) + "\n\n")
  );
}

function generateInitialMigration(
  diagram: Diagram,
  timestamp: string
): string {
  const { nodes, edges } = diagram.data;
  
  // Sort nodes by their order property to respect table serial from inspector
  const sortedNodes = nodes
    .filter((n) => !n.data.isDeleted)
    .sort((a, b) => {
      const orderA = a.data.order ?? 0;
      const orderB = b.data.order ?? 0;
      return orderA - orderB;
    });

  const operations: string[] = [];

  // Generate CreateModel operations for each table
  for (const node of sortedNodes) {
    const operation = generateCreateModelOperation(node, diagram, edges);
    operations.push(operation);
  }

  // Generate additional operations (AlterModelOptions, RenameField, etc.)
  const additionalOperations = generateAdditionalOperations(diagram);
  operations.push(...additionalOperations);

  const operationsStr = operations.map(op => `        ${op}`).join(',\n');

  const currentDate = new Date();
  const dateStr = currentDate.toISOString().split('T')[0];
  const timeStr = currentDate.toTimeString().split(' ')[0].replace(/:/g, '');

  return `# Generated by Database Designer on ${dateStr} ${timeStr.slice(0, 4)}

from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
${operationsStr}
    ]
`;
}

function generateCreateModelOperation(
  node: AppNode,
  diagram: Diagram,
  edges: AppEdge[]
): string {
  const modelName = toDjangoModelName(node.data.label);
  const tableName = toDjangoTableName(node.data.label);
  
  // Generate fields
  const fields: string[] = [];
  
  // Add fields
  for (const column of node.data.columns) {
    const field = generateFieldDefinition(column, node, edges, diagram.dbType);
    fields.push(field);
  }
  
  // Format fields
  const fieldsStr = fields.map(f => `                ${f}`).join(',\n');
  
  // Generate model options
  let optionsStr = '';
  // Add default ordering by primary key if exists
  const pkColumn = node.data.columns.find(col => col.pk);
  if (pkColumn) {
    optionsStr = `            options={
                'ordering': ('-${pkColumn.name}',),
            },`;
  }
  
  return `migrations.CreateModel(
            name='${modelName}',
            fields=[
${fieldsStr}
            ],
${optionsStr}
        )`;
}

function generateFieldDefinition(
  column: Column,
  node: AppNode,
  edges: AppEdge[],
  dbType: 'mysql' | 'postgres'
): string {
  // Handle primary key field
  if (column.pk) {
    // Check if it's an auto increment field
    if (column.isAutoIncrement) {
      return `('${column.name}', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID'))`;
    }
    // For non-auto increment primary keys, use the appropriate field type
    const fieldType = getDjangoFieldType(column.type, dbType);
    const options = extractFieldOptions(column.type, column);
    const optionsStr = options.length > 0 ? `, ${options.join(', ')}` : '';
    return `('${column.name}', ${fieldType}(primary_key=True${optionsStr}))`;
  }
  
  // Handle foreign key relationships
  const fkEdge = edges.find(edge => {
    // Extract column ID from handle ID
    const getColumnIdFromHandle = (handleId: string | null | undefined): string | null => {
      if (!handleId) return null;
      const parts = handleId.split('-');
      return parts.length >= 3 ? parts.slice(0, -2).join('-') : handleId;
    };
    
    const sourceColumnId = getColumnIdFromHandle(edge.sourceHandle);
    const targetColumnId = getColumnIdFromHandle(edge.targetHandle);
    
    // Check if this column is part of a foreign key relationship
    return sourceColumnId === column.id || targetColumnId === column.id;
  });
  
  if (fkEdge) {
    // Determine the target table and column
    let targetNode, targetColumn;
    
    // Extract column ID from handle ID
    const getColumnIdFromHandle = (handleId: string | null | undefined): string | null => {
      if (!handleId) return null;
      const parts = handleId.split('-');
      return parts.length >= 3 ? parts.slice(0, -2).join('-') : handleId;
    };
    
    const sourceColumnId = getColumnIdFromHandle(fkEdge.sourceHandle);
    const targetColumnId = getColumnIdFromHandle(fkEdge.targetHandle);
    
    if (sourceColumnId === column.id) {
      // This node is the source (referencing table)
      targetNode = diagram.data.nodes.find(n => n.id === fkEdge.target);
      if (targetNode) {
        targetColumn = targetNode.data.columns.find(c => c.id === targetColumnId);
      }
    } else if (targetColumnId === column.id) {
      // This node is the target (referenced table)
      targetNode = diagram.data.nodes.find(n => n.id === fkEdge.source);
      if (targetNode) {
        targetColumn = targetNode.data.columns.find(c => c.id === sourceColumnId);
      }
    }
    
    if (targetNode && targetColumn) {
      const targetModelName = toDjangoModelName(targetNode.data.label);
      const onDeleteAction = getDjangoOnDeleteAction(fkEdge.data?.relationship);
      
      // Add default value if specified
      let defaultValue = '';
      if (column.defaultValue !== undefined && column.defaultValue !== null) {
        if (typeof column.defaultValue === 'string') {
          defaultValue = `, default='${escapeString(String(column.defaultValue))}'`;
        } else {
          defaultValue = `, default=${column.defaultValue}`;
        }
      }
      
      return `('${column.name}', models.ForeignKey(${onDeleteAction}${defaultValue}, to='${targetModelName.toLowerCase()}.${targetColumn.name}'))`;
    }
  }
  
  // Handle regular fields
  const fieldType = getDjangoFieldType(column.type, dbType);
  const options = extractFieldOptions(column.type, column);
  
  // Add null=False for non-nullable fields (except primary keys which are handled separately)
  if (column.nullable === false && !column.pk) {
    options.push('null=False');
  } else if (column.nullable === true) {
    options.push('null=True');
  }
  
  const optionsStr = options.length > 0 ? `, ${options.join(', ')}` : '';
  return `('${column.name}', ${fieldType}(${optionsStr.slice(2)}))`;
}

function generateAdditionalOperations(diagram: Diagram): string[] {
  const operations: string[] = [];
  
  // This function should be extended to handle user-defined operations
  // For now, we'll provide a way to add example operations for testing
  
  // Example operations based on your examples:
  // These would typically come from a separate configuration or user actions
  // that modify existing models rather than initial creation
  
  // Check if this is a test scenario where we want to add example operations
  // In a real implementation, this would be controlled by user input or diagram metadata
  const addExampleOperations = process.env.ADD_DJANGO_EXAMPLE_OPERATIONS === 'true';
  
  if (addExampleOperations) {
    // Add AlterModelOptions operation to change Post model ordering
    operations.push(`migrations.AlterModelOptions(
            name='post',
            options={'ordering': ('-name',)},
        )`);
    
    // Add RenameField operation to rename title to name in Post model
    operations.push(`migrations.RenameField(
            model_name='post',
            old_name='title',
            new_name='name',
        )`);
  }
  
  return operations;
}

function generateForeignKeyMigration(
  timestamp: string,
  diagram: Diagram
): string {
  const sql = exportToSql(diagram);
  
  // Split SQL into individual statements and clean them
  const statements = sql
    .split(";")
    .map((stmt) => stmt.trim())
    .filter((stmt) => stmt.length > 0);

  // Find ALTER TABLE statements that add foreign key constraints
  const alterTableStatements = statements.filter((stmt) =>
    stmt.toUpperCase().includes("ADD CONSTRAINT") &&
    stmt.toUpperCase().includes("FOREIGN KEY")
  );

  if (alterTableStatements.length === 0) {
    return "";
  }

  let migration = `# Generated by Database Designer
# Foreign Key Constraints Migration

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        # Add your app dependencies here
    ]

    operations = [`;

  alterTableStatements.forEach((alterSql) => {
    const formattedAlterSql = formatSqlForDjango(alterSql);
    const dropFkSql = generateDropForeignKeyStatement(alterSql, diagram.dbType);
    
    migration += `
        migrations.RunSQL(
            "${formattedAlterSql}",
            reverse_sql="${dropFkSql}"
        ),`;
  });

  migration += `
    ]
`;

  return migration;
}

function formatSqlForDjango(sql: string): string {
  if (!sql) return "";

  // Escape quotes for Django string literals
  let formatted = sql.replace(/"/g, '\\"');

  // Clean up extra whitespace but preserve structure
  formatted = formatted
    .replace(/\s+/g, " ") // Replace multiple spaces with single space
    .replace(/;\s*$/, "") // Remove trailing semicolon
    .trim(); // Remove leading/trailing whitespace

  return formatted;
}

function generateDropTypeStatement(createTypeSql: string): string {
  // Extract type name from CREATE TYPE statement
  const typeMatch = createTypeSql.match(/CREATE\s+TYPE\s+([^\s]+)/i);
  if (typeMatch) {
    const typeName = typeMatch[1];
    return `DROP TYPE IF EXISTS ${typeName};`;
  }
  return "";
}

function generateDropIndexStatement(indexSql: string, dbType: string): string {
  // Extract index name from CREATE INDEX statement
  const indexMatch = indexSql.match(/CREATE\s+(?:UNIQUE\s+)?INDEX\s+([^\s]+)/i);
  if (indexMatch) {
    const indexName = indexMatch[1];
    if (dbType === 'postgres') {
      return `DROP INDEX IF EXISTS ${indexName};`;
    } else {
      // MySQL - need to extract table name
      const tableMatch = indexSql.match(/ON\s+([^\s(]+)/i);
      if (tableMatch) {
        const tableName = tableMatch[1];
        return `DROP INDEX ${indexName} ON ${tableName};`;
      }
    }
  }
  return "";
}

function generateDropCommentStatement(commentSql: string): string {
  // Extract table and column from COMMENT statement
  const commentMatch = commentSql.match(/COMMENT\s+ON\s+COLUMN\s+([^.]+)\.([^\s]+)/i);
  if (commentMatch) {
    const tableName = commentMatch[1];
    const columnName = commentMatch[2];
    return `COMMENT ON COLUMN ${tableName}.${columnName} IS NULL;`;
  }
  return "";
}

function generateDropForeignKeyStatement(
  alterSql: string,
  dbType: string
): string {
  // Extract foreign key constraint name and table from ALTER TABLE statement
  const tableMatch = alterSql.match(/ALTER\s+TABLE\s+([^\s]+)/i);
  const fkMatch = alterSql.match(/CONSTRAINT\s+([^\s]+)\s+FOREIGN\s+KEY/i);
  
  if (tableMatch && fkMatch) {
    const tableName = tableMatch[1];
    const constraintName = fkMatch[1];
    
    if (dbType === 'postgres') {
      return `ALTER TABLE ${tableName} DROP CONSTRAINT ${constraintName};`;
    } else {
      return `ALTER TABLE ${tableName} DROP FOREIGN KEY ${constraintName};`;
    }
  }
  return "";
}

export {
  generateDjangoMigration,
  generateDjangoMigrationString,
};